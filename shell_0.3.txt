#include "shell.h"

/**
 * getcmd - reads the command using getline.
 * @cmd: memory location of the command read.
 * @len: the length parameter for getline.
 *
 * Return: the length of the input.
 */

ssize_t getcmd(char **cmd, size_t *len)
{
	ssize_t read_len;

	if (isatty(fileno(stdin)))
		write(STDOUT_FILENO, ":) ", 3);

	read_len = getline(cmd, len, stdin);
	if (read_len == -1)
	{
		if (feof(stdin))
		{
			free(*cmd);
			exit(EXIT_SUCCESS);
		}
		perror("getline");
		free(*cmd);
		exit(EXIT_FAILURE);
	}

	if (read_len > 0 && (*cmd)[read_len - 1] == '\n')
		(*cmd)[read_len - 1] = '\0';

	return (read_len);
}

/**
 * is_full_path - checks if the command is entered using full path.
 * @cmd: the command to check.
 *
 * Return: true if cm is a full path, false otherwise.
 */

bool is_full_path(char *cmd)
{
	if (strncmp(cmd, "/bin/", 5) == 0)
		return (true);
	return (false);
}

/**
 * handle_path - handles the full path if the command is not entered
 * with full path.
 * @cmd: command to check.
 * Return: the command's full path.
 */

char *handle_path(char *cmd)
{
	char *path = getenv("PATH"), *pathcpy = strdup(path);
	char *exec, *dir = strtok(pathcpy, ":");

	if (is_full_path(cmd))
	{
		if (access(cmd, X_OK) == 0)
			return (cmd);
		return (NULL);
	}

	while (dir != NULL)
	{
		exec = malloc(strlen(dir) + strlen(cmd) + 2);
		strcpy(exec, dir);
		strcat(strcat(exec, "/"), cmd);
		if (access(exec, X_OK) == 0)
		{
			free(pathcpy);
			return (exec);
		}
		free(exec);
		dir = strtok(NULL, ":");
	}
	free(pathcpy);
	return (NULL);
}

/**
 * execute - forks a child process and executes the command using execve.
 * @tokens: an array of strings containing the command to execute.
 * @av: argument vector from main containing the name of the program.
 * @env: the list of environment variables.
 *
 * Return: the child pid on success or -1 on failure.
 */

int execute(char **tokens, char **av, char **env)
{
	int status;
	pid_t pid;

	pid = fork();
	if (pid == -1)
	{
		perror("fork");
		exit(EXIT_FAILURE);
	} else if (pid == 0)
	{
		if (execve(tokens[0], tokens, env) == -1)
		{
			perror(av[0]);
			exit(EXIT_FAILURE);
		}
	} else
		if (wait(&status) == -1)
		{
			perror("wait");
			exit(EXIT_FAILURE);
		}

	return (status);
}

/**
 * main - UNIX command line interpreter.
 * @ac: argument count.
 * @av: list of arguments.
 * @env: vector of environment variables.
 *
 * Return: 0 (Success).
 */

int main(int ac __attribute__((unused)), char **av, char **env)
{
	char *command, *cmd, **tokens;
	size_t len = 0;
	ssize_t read_len;
	bool interactive = isatty(fileno(stdin));

	while (1)
	{
		cmd = command = NULL;
		tokens = malloc((MAX_TOK_LEN + 1) * sizeof(char *));
		read_len = getcmd(&command, &len);
		if (!interactive && read_len <= 1)
			break;
		split(command, " \t\n", tokens, MAX_TOK_LEN);
		cmd = strdup(tokens[0]);
		if (cmd == NULL)
		{
			perror(av[0]);
			free_tokens(tokens);
			continue;
		}
		tokens[0] = handle_path(cmd);
		if (tokens[0] == NULL)
		{
			perror(av[0]);
			free_tokens(tokens);
			continue;
		}
		free(cmd);
		if (execute(tokens, av, env) == -1)
		{
			free_tokens(tokens);
			exit(EXIT_FAILURE);
		}
		free_tokens(tokens);
	}

	free(command);
	free_tokens(tokens);
	return (0);
}
